### HTTP

HTTP 是一种超文本协议，它是无状态的协议，也就是一次请求响应之后，服务器不会记住客户端的状态。

#### HTTP 0.9

最早诞生的 HTTP 0.9 主要用来传输超文本 HTML，用于学术交流，它的实现很简单，就是基于请求响应的模式，从客户端发出请求，服务器返回数据。只有请求行，并且是通过 ASCLL 字节码传输

![image](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png)

#### HTTP 1.0

随着万维网的发展，浏览器不仅只展示 HTML 文件，需要处理 javascript、css、图片、音频、视频等文件，因此 HTTP 1.0 需要支持多种文件类型的下载，HTTP 1.0 引入了请求头和响应头。在支持多种文件类型的基础上，还提供了 Cache 机制，用户代理，响应码等信息

![image](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)

#### HTTP 1.1

在 HTTP 1.0 中没进行一次 HTTP 通信，都需要进行 TCP 连接和断开，所以 HTTP 1.1 引入了持久连接，减少大量 TCP 连接断开的开销，HTTP 1.1 默认开启持久连接，只要浏览器或服务器没有明确断开，TCP 连接就不会断开。浏览器中对于一个域名，最多可以有6个 TCP 持久连接

![image](https://static001.geekbang.org/resource/image/80/1a/80b57830e15faa17631bea74054a0e1a.png)

在一个 TCP 连接中，如果有一个请求挂掉，就会阻塞后面的请求，这就是队头阻塞问题。为了解决这个问题，在 HTTP 1.1 试图通过管线化技术解决，管线化指的是多个 HTTP 请求批量发送给服务器，服务器按顺序返回。由于各种原因，最终放弃了管线化技术

除此之外，HTTP 1.1 还引入了 Cookie、虚拟主机，动态内容的支持等特性

---

### HTTP 2.0

HTTP 1.1 的主要问题是对带宽的利用率不高，带宽指的是每秒最大能发送和接送的字节数。有三个原因影响到：

- TCP 慢启动
- 多个 TCP 连接竞争有限的带宽
- 队头阻塞

HTTP 2.0 主要思路是一个域名只使用一个 TCP 长连接传输数据，这样整个页面就只需要一次慢启动，也不会有多个 TCP 连接之间竞争带宽。**HTTP 2.0 最核心，最重要且最颠覆性的机制是多路复用机制**

![image](https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg)

多路复用的实现

![image](https://static001.geekbang.org/resource/image/86/6a/86cdf01a3af7f4f755d28917e58aae6a.png)

HTTP 2.0 添加了一个二进制分帧层，请求和接受过程如下:

- 浏览器准备好请求数据，包括请求行，请求头，如果是 post 方法那么还有请求体
- 这些数据通过二进制分帧层，会被转换成一个个带有 ID 的帧，这些帧通过协议栈发送给服务器
- 服务器接收到所有帧之后，会把同样 ID 的帧组合成一个完整的请求
- 然后服务器处理这条请求，并把处理好的响应行，响应头，响应体发送给二进制分帧层
- 二进制分帧层把这些响应数据转换为一个个带有 ID 的帧，经过协议栈发送给浏览器
- 浏览器把响应帧，把同样 ID 的帧组合成一个完整的响应信息

二级制分帧层还能实现请求的优先级，服务器推送，头部压缩等特性

---

### HTTP 3.0

因为 HTTP 2.0 是基于 TCP 协议的，所以还存在 TCP 队头阻塞，建立 TCP 连接的延迟、TCP 协议僵化问题

#### TCP 队头阻塞

TCP 最初的设计就是为了单连接，TCP 连接可以想象成两台计算机的一个虚拟管道，计算机一段将数据按顺序放入管道，最终数据会以相同数据出现在另外一头

如果传输的过程中有一个数据包因为网络故障丢包了，整个 TCP 连接就会处于暂停状态，需要等待丢失的数据包重新传输过来

![image](https://static001.geekbang.org/resource/image/33/96/33d2b4c14a7a2f19ef6677696b67de96.png)

HTTP 2.0中，多个请求是跑在一个 TCP 管道中，如果有一路数据流丢包，就会阻塞该 TCP 连接中的所有请求

![image](https://static001.geekbang.org/resource/image/48/d1/4837434655a6d87f1bf5e3d899a698d1.png)

#### TCP 建立连接的延时

网络延迟又称为 RTT（Round Trip Time）我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标

![image](https://static001.geekbang.org/resource/image/e9/4f/e98927e19b20349815fb8f499067cb4f.png)

TCP 连接三次握手，TLS 握手延迟时间大概需要花掉 3-4 个 RTT，如果浏览器和服务器的物理距离较远，整个握手过程需要 300 - 400 毫秒

#### TCP 协议僵化

中间设备的僵化，操作系统导致 TCP 协议僵化，所以很难更新 TCP 协议

#### QUIC 协议

基于 UDP 实现了类似 TCP 的多路数据流，传输可靠性等功能的协议

![image](https://static001.geekbang.org/resource/image/0b/c6/0bae470bb49747b9a59f9f4bb496a9c6.png)

HTTP 3.0 使用了 QUIC 协议集合了以下功能：

- 实现了类似 TCP 的流量控制，传输可靠性的功能

- 集成了 TLS 加密功能

- 实现了 HTTP 2.0 的多路复用功能，解决了队头阻塞问题

  ![image](https://static001.geekbang.org/resource/image/05/9a/05cc5720989aec75730ee4cb7e7c149a.png)

- 实现了快速握手功能

---

### HTTPS

因为 HTTP 是明文传输的，在传输的过程中，数据有可能被窃取或者篡改，使用 HTTP 传输的内容很容易被中间人窃取，伪造和篡改，通常把这种攻击称为**中间人攻击**

![image](https://static001.geekbang.org/resource/image/11/e2/118ced11537bd1e257f8df09380f33e2.png)

HTTPS 就是在 HTTP 和 TCP 之间插入一个安全层，安全层的职责就是对发起的 HTTP 请求的数据进行加密操作和对接收到的 HTTP 的内容进行解密操作

![image](https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png)

#### 第一版：使用对称加密

对称加密是指加密和解密都使用相同的密钥，过程如下

![image](https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png)

因为传输过程中的 client-random 和 service-random 的过程是明文的，意味着黑客也可以拿到协商的加密套件和随机数，然后合成密钥，数据也可以被破解

#### 第二版：使用非对称加密

非对称加密算法有 A、B 两把密钥，如果 A 密钥来加密，那么只能使用 B 密钥来解密。反过来，如果用 B 密钥来加密，那么只能用 A 密钥来解密

HTTPS 过程中，服务器会将公钥明文发给浏览器，会把私钥自己留下，公钥每个人都可以获取到，私钥只有服务器知道，不对任何人公开

![image](https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png)

采用非对称加密，能保证浏览器发给服务器的数据是安全的，但还是有两个问题：

- 非对称加密效率太低，严重影响到加解密数据的速度，从而影响到用户打开页面的速度
- 无法保证服务器发送给浏览器的数据安全，因为服务器只能采用私钥加密，而公钥能被黑客获取到，所以可以用公钥解密数据

#### 第三版：对称加密 + 非对称加密

在传输数据时候使用对称加密，但是对称加密的密钥使用非对称加密来传输

![image](https://static001.geekbang.org/resource/image/d5/45/d5cd34dbf3636ebc0e809aa424c53845.png)

重点在于 pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程的数据了

#### 第四版：添加数字证书

通过权威认证结构 CA 颁发数字证书，数字证书的作用：

- 通过数字证书证明服务器的身份
- 数字证书里面包含服务器公钥

![image](https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png)

有两点改变了：

1. 服务器没有返回公钥，而是返回了数字证书，公钥包含在数字证书中
2. 在浏览器端多了一个验证证书的操作，验证通过了之后，才继续后续流程

#### 如何申请数字证书

- 准备一套私钥和公钥，私钥自己留着
- 向 CA 机构提供公钥，公司，站点等信息并等待认证，这个认证过程可能收费
- CA 通过各种渠道验证信息的真实性
- 审核通过后，CA 会向站点签发数字证书，包含各种信息，都是明文的，同时包含一个数字签名

数字签名：首先 CA 使用 Hash 函数来计算站点提交的明文信息，并得出信息摘要，然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是数字签名，相当于在上面盖个章，这个章可以去验证的

#### 浏览器如何验证数字证书

浏览器接收到服务器返回的数字证书。首先会读取证书中的明文信息，采用 CA 签名相同的 Hash 函数来计算得到信息摘要 A，然后利用CA 的公钥解密签名数据，得到信息摘要 B，对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的。

---

### TCP & UDP

#### UDP特点

UDP 面向非连接，不可靠，不保证不丢失，不保证按顺序到达，没有拥塞机制，不会根据网络环境调整发送的速度，可以广播

![image](https://static001.geekbang.org/resource/image/2c/84/2c9a109f3be308dea901004a5a3b4c84.jpg)

#### UDP 使用场景

- 需要资源少，在网络比较好的内网，对于丢包不敏感的应用
- 不需要一对一沟通，建立连接，可以广播的应用
- 需要处理速度快，时延低，可以容忍少数丢包，要求即便网络拥塞，也毫不退缩

#### TCP

![image](https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg)

序号是一个自增的序号，为了解决乱序的问题；确认序号是为了解决丢包问题；状态位 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接；窗口大小是 TCP 的流量控制，通信双方各声明一个窗口，标识自己当前能够处理的能力，通过滑动窗口动态调整发送的速度；拥塞机制就是根据网络的状况调整发送的速度

#### TCP 三次握手

![image](https://static001.geekbang.org/resource/image/c0/08/c067fe62f49e8152368c7be9d91adc08.jpg)

三次握手除了双方建立连接之外，主要还有沟通 TCP 包序号的问题，为什么是三次握手呢？三次握手是证明客户端和服务端的接收和发送能力正常的最小握手次数，两次握手服务端不知道自己的发送能力是否正常，需要客户端再发送一个 ACK 包告诉服务端你的发送能力是正常的，四次握手浪费时间

#### TCP 四次挥手

![image](https://static001.geekbang.org/resource/image/bf/13/bf1254f85d527c77cc4088a35ac11d13.jpg)

MSL: 报文最大生存时间，协议规定 MSL 为2分钟，它是任何报文在网络上存在的最长时间，超过这个时间的报文将被丢弃

等待 2MSL 的原因是防止客户端的 ACK 包丢失，服务端会重新发送 FIN 包，客户端接收不到。另一个原因释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络中的老的 TCP 报文会与新的 TCP 报文冲突，造成数据冲突，为了避免这种情况需要耐心等待网络中老的 TCP 报文全部失效

